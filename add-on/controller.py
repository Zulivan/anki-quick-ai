from aqt import mw
from aqt.utils import showInfo
from aqt.operations import QueryOp

import openai
import playsound
import os
import threading
from PyQt6.QtWidgets import QWidget, QVBoxLayout, QLabel, QPushButton

from .anki import get_note_field_value_list
from .gpt import call_openai, make_edge_tts_mp3



class StoryThread(threading.Thread):
    def __init__(self, browse_cmd):
        super().__init__()
        self.browse_cmd = browse_cmd
        self.words = None
        self.story = None
        self.trans_story = None
        self.daemon = True  # Set the thread as daemon

    def run(self):
        # self.words, self.story, self.trans_story = get_story_from_ai(self.browse_cmd)
        config = mw.addonManager.getConfig(__name__)
        openai.api_key = config["api_key"]
        story_lang = config["story_language"]
        trans_lang = config["trans_language"]
        model = config["model"]

        words = get_note_field_value_list(self.browse_cmd)

        prompt = config["prompt"].format(language=story_lang, words=words)
        story = call_openai(prompt,  model)

        prompt_trans = config["prompt_translation"].format(text=story, language=trans_lang)
        trans_story = call_openai(prompt_trans, model)

        self.words = words
        self.story = story
        self.trans_story = trans_story


class SoundThread(threading.Thread):
    def __init__(self, story, trans_story, story_lang, trans_lang):
        super().__init__()
        self.story = story
        self.trans_story = trans_story
        self.story_lang = story_lang
        self.trans_lang = trans_lang
        self.daemon = True  # Set the thread as daemon

    def run(self):
        if not os.path.exists(os.path.join(os.path.dirname(__file__), "output")):
            os.makedirs(os.path.join(os.path.dirname(__file__), "output"))
        make_edge_tts_mp3(self.story, self.story_lang, os.path.join(os.path.dirname(__file__), "output", "story.mp3"))
        make_edge_tts_mp3(self.trans_story, self.trans_lang, os.path.join(os.path.dirname(__file__), "output", "translated_story.mp3"))
        playsound.playsound(os.path.join(os.path.dirname(__file__), "output", "story.mp3"))
        playsound.playsound(os.path.join(os.path.dirname(__file__), "output", "translated_story.mp3"))


class ChooseWidget(QWidget):
    def __init__(self):
        super().__init__()
        self.initUI()

    def initUI(self):
        layout = QVBoxLayout()
        self.setLayout(layout)

        label = QLabel("Whether to run the add-on \"AI Words Story\"?\nIt may takes seconds for AI to generate contents, and another seconds for sound generation.")
        layout.addWidget(label)

        run_button = QPushButton("Run")
        run_button.clicked.connect(self.runAddon)
        layout.addWidget(run_button)

        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(self.close)
        layout.addWidget(cancel_button)

    def runAddon(self):
        # Logic to run your add-on goes here
        # print("Running Add-on")
        self.close()
        gen_words_story()


def show_story(words, story, trans_story):
    color = 'green'
    words_str = '<br>'.join(words)
    showInfo(f"<font color='{color}'>Today's Words:</font><br>{words_str}<br><br><font color='{color}'>Article Generated by ChatGPT:</font><br><br>{story}<br><br><font color='{color}'>Translation Generated by ChatGPT:</font><br><br>{trans_story}")


def show_story_and_play_sound(words, story, trans_story, story_lang = None, trans_lang = None):
    # play sound
    if mw.addonManager.getConfig(__name__)["play_sound"]:
        music_thread = SoundThread(story, trans_story, story_lang, trans_lang)
        music_thread.start()

    # show story
    show_story(words, story, trans_story)


def choose_running_add_on():
    mw.chooseWidget = ChooseWidget()
    mw.chooseWidget.show()


def gen_words_story() -> None:
    config = mw.addonManager.getConfig(__name__)
    story_thread = StoryThread(config["query"])

    def run_story_thread(story_thread):
        story_thread.start()
        story_thread.join()

    op_story = QueryOp(
        # the active window (main window in this case)
        parent=mw,
        # the operation is passed the collection for convenience; you can
        # ignore it if you wish
        op=lambda col: run_story_thread(story_thread),
        # this function will be called if op completes successfully,
        # and it is given the return value of the op
        success=lambda x: show_story_and_play_sound(story_thread.words, story_thread.story, story_thread.trans_story, config["story_language"], config["trans_language"])
    )

    op_story.with_progress().run_in_background()
